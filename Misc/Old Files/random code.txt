//#pragma warning (disable: 4786)

/*
#define UsingVisualStudioNet 0
//#define UsingVisualStudioNet 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>    
#if UsingVisualStudioNet
	#include <iostream> 
	#include <fstream>
#else
	#include <iostream.h> 
	#include <fstream.h>
#endif
#include "GLUT/glut.h"
#include "logging.h"
#include "fileDialog.h"
#include "vector"
#include "map"
#include "string"
*/

bool insideOf(Point & p) const;
double maxX, maxY, maxZ;
double minX, minY, minZ;

bool Pool::insideOf(Point & p) const {
	return p.x >= minX && p.x <= maxX &&
		   p.y >= minY && p.y <= maxY &&
		   p.z >= minZ && p.z <= maxZ;
}


	GamePoint * p;
	
	for(int i=0;i<faces.size();i++) {
		for(int j=0;j<faces.at(i)->points.size();j++) {
			p = faces.at(i)->points.at(j);
			if(i==0 && j==0) {
				maxX = p->x; minX = p->x;
				maxY = p->y; minY = p->y;
				maxZ = p->z; minZ = p->z;
			}
			else {
				if(p->x > maxX) { maxX = p->x; }
				if(p->y > maxY) { maxY = p->y; }
				if(p->z > maxZ) { maxZ = p->z; }
				if(p->x < minX) { minX = p->x; }
				if(p->y < minY) { minY = p->y; }
				if(p->z < minZ) { minZ = p->z; }
			}
		}
	}
	printf("max: (%f, %f, %f)\n", maxX, maxY, maxZ);
	printf("min: (%f, %f, %f)\n", minX, minY, minZ);


			// left side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, 0.5, 1-width, width);
			drawPoint(-0.5,0.5, -0.5, width, width);
			drawPoint(-0.5,-0.5, -0.5, width, 1-width);
			drawPoint(-0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();
			
			// right side
			glBegin(GL_POLYGON);
			drawPoint(0.5,0.5, -0.5, 1-width, width);
			drawPoint(0.5,0.5, 0.5, width, width);
			drawPoint(0.5,-0.5, 0.5, width, 1-width);
			drawPoint(0.5,-0.5, -0.5, 1-width, 1-width);
			glEnd();

			// front side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, -0.5, 1-width, width);
			drawPoint(0.5,0.5, -0.5, width, width);
			drawPoint(0.5,-0.5, -0.5, width, 1-width);
			drawPoint(-0.5,-0.5, -0.5, 1-width, 1-width);
			glEnd();

			// back side
			glBegin(GL_POLYGON);
			drawPoint(0.5,0.5, 0.5, 1-width, width);
			drawPoint(-0.5,0.5, 0.5, width, width);
			drawPoint(-0.5,-0.5, 0.5, width, 1-width);
			drawPoint(0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();

			// top side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, 0.5, 1-width, width);
			drawPoint(0.5,0.5, 0.5, width, width);
			drawPoint(0.5,0.5, -0.5, width, 1-width);
			drawPoint(-0.5,0.5, -0.5, 1-width, 1-width);
			glEnd();

			// bottom side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,-0.5, -0.5, 1-width, width);
			drawPoint(0.5,-0.5, -0.5, width, width);
			drawPoint(0.5,-0.5, 0.5, width, 1-width);
			drawPoint(-0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();


	// collect waypoints and add neighbouring waypoints to each waypoint object, then collect the waypoints in the main object collection
	char * separator;
	char * head;
	char * start;
	char * end;
	bool valid;
	bool endOfString;
	for(i=0;i<waypoints.size();i++) {
		// parse through the string of neighbour waypoint values
		head = waypoints.at(i)->neighbourValues;
		do {
			// trim whitespace
			valid = true;
			endOfString = false;
			separator = strchr(head, ',');
			if(separator == NULL) {
				separator = head + ((strlen(head) - 1) * sizeof(char) + sizeof(char));
				endOfString = true;
			}
			else {
				*separator = '\0';
			}
			start = head;
			end = separator - sizeof(char);
			// trim the front of the string
			while(*start == ' ' || *start == '\t') {
				*start = '\0';
				start += sizeof(char);
			}
			// trim the end of the string
			while(*end == ' ' || *end == '\t') {
				*end = '\0';
				end -= sizeof(char);
			}
			if(start > end) {
				valid = false;
			}
			head = start;
			
			// set each waypoint as a neighbour of the other
			if(valid) {
				for(j=0;j<waypoints.size();j++) {
					if(stricmp(head, waypoints.at(j)->name) == 0 ){
						waypoints.at(i)->addNeighbour(waypoints.at(j));
						waypoints.at(j)->addNeighbour(waypoints.at(i));
					}
				}

			}
			
			// iterate to the next element in the string
			head = separator + sizeof(char);
		} while(!endOfString);
	}



void Waypoint::addNeighbour(Waypoint * w) {
	if(w == NULL) { return; }
	
	bool valid = true;

	for(int i=0;i<this->neighbours.size();i++) {
		if(stricmp(this->neighbours.at(i)->name, w->name) == 0 || stricmp(this->name, w->name) == 0) {
			valid = false;
		}
	}
	
	if(valid) {
		this->neighbours.push_back(w);
	}
}



		else if(stricmp(key, "waypoint") == 0) {
			for(int i=0;i<waypoints.size();i++) {
				if(stricmp(waypoints.at(i)->name, str) == 0) {
					origin = waypoints.at(i);
					break;
				}
			}
			delete [] str;
		}



//Input the texture names and load the corresponding texture
	SKIP_TO_COLON;
	SKIP_TO_SEMICOLON;
	long texturesSize = atoi(line);
	CLEAR_THE_LINE;
	char * textureName;
	int startIndex;
	int i, j;
	string texturePath;
//	string texturePathBMP;
//	string texturePathTGA;
	Texture * newTexture;
	for(long textureIndex = 0; textureIndex < texturesSize; textureIndex++) {
		SKIP_TO_ENDLINE;
		startIndex = 0;
		for(i=startIndex;i<strlen(line);i++) {
			if(line[i] != ' ' && line[i] != '\t') {
				startIndex = i;
				break;
			}
		}
		textureName = new char[strlen(line) - startIndex + 1];
		j = 0;
		for(i=startIndex;i<strlen(line);i++) {
			textureName[j++] = line[i];
		}
		textureName[strlen(line) - startIndex] = '\0';

		//Load the texture
		texturePath.append(textureDirectory);
		texturePath.append("/");
		texturePath.append(textureName);
		newTexture = Texture::readTexture((char *) texturePath.c_str());
//		texturePathTGA.append(texturePath);
//		texturePathTGA.append(".tga");
//		newTexture = Texture::readTexture((char *) texturePathTGA.c_str());
//		if(newTexture == NULL) {
//			texturePathBMP.append(texturePath);
//			texturePathBMP.append(".bmp");
//			newTexture = Texture::readTexture((char *) texturePathBMP.c_str());
//		}
		if(newTexture != NULL) {
			newTexture->load();
			textures.push_back(newTexture);
		}
		else {
			prompt("Missing texture: %s", textureName);
		}
		texturePath.erase();
//		texturePathBMP.erase();
//		texturePathTGA.erase();
		delete [] textureName;
	}




//#define matches(a,b) strlen(b) >= strlen(a) && memcmp(a,b,strlen(a)) == 0

inline bool keyIsDown(int key) {
	return (GetAsyncKeyState(key) & 0x8000) != 0;
}





void Game::drawMessage(long x, long y, const char *message, ...) {
	char * text;
	text = new char[512];
	
	va_list parameters;									
	if(message == NULL) return;

	//Extract variable length parameters and copy into text as in printf.
	va_start (parameters, message);					
	    vsprintf (text, message, parameters);		
	va_end (parameters);

	//Determine the end of the string and convert each occurrence of '\n' to '\0'.
	char *end = text + strlen (text);
	for (char *next = text; *next != '\0'; next++) {
		if (*next == '\n') *next = '\0';
	}

	//Draw the multi-line message...
	begin2DDrawing ();
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_LIGHTING);
	glColor4f(1.0f,1.0f,1.0f,1.0f);
	int yOffset = y;
	for(char * line=text;line<end;line+=strlen(line)+1) {
		glRasterPos2i(x, yOffset);
		yOffset -= 32;
		privateDrawString (line);
	}
	end2DDrawing();

	delete [] text;
}

void Game::drawFrameRate () {
	//Draw the frame rate avoiding extreme fluctuations (since all you see is flickering).
	double frameRate = 1.0 / DT; //Frames/sec = 1/(seconds per frame).
	static double stableRate = frameRate; //This initializes only the first time...
	static double oldFrameRate = frameRate;
	//If it changed by more than 2 per cent of the stable value, use the new value; otherwise use the stable one...
	if(absolute(frameRate - stableRate) > 2.0) stableRate  = frameRate; 
	drawMessage(1, screenHeight-20, "FPS: %3.1f", stableRate);
}

void Game::drawNote (const char *message, ...) {
	char text[1000];
	va_list parameters;									
	if (message == NULL) return;
	
	//Extract variable length parameters and copy into text as in printf.
	va_start(parameters, message);					
	    vsprintf(text, message, parameters);		
	va_end(parameters);

	drawMessage(1, screenHeight-52, "%s", text);
}




void Game::loadMapPrompt() {
	closeWorld();
	
	char * fileName = NULL;
	char * filenameBuffer = new char[MAX_PATH];
	filenameBuffer[0] = '\0';
	
	OPENFILENAME query;
	query.lStructSize = sizeof(OPENFILENAME);
	query.hwndOwner = NULL;
	query.hInstance = GetModuleHandle(NULL);
	query.lpstrFilter = worldFileFilter;
	query.lpstrCustomFilter = NULL;
	query.nMaxCustFilter = 0;
	query.nFilterIndex = 0;
	query.lpstrFile = filenameBuffer;
	query.nMaxFile = MAX_PATH;
	query.lpstrFileTitle = NULL;
	query.nMaxFileTitle = MAX_PATH;
	query.lpstrInitialDir = settings->getValue("Map Directory");
	query.lpstrTitle = NULL;
	query.Flags = OFN_NOCHANGEDIR;
	query.nFileOffset = 0;
	query.nFileExtension = 0;
	query.lpstrDefExt = NULL;
	query.lCustData = 0;
	query.lpfnHook = NULL;
	query.lpTemplateName = NULL;
	
	if(GetOpenFileName(&query)) {
		fileName = new char[strlen(query.lpstrFile) + 1];
		strcpy(fileName, query.lpstrFile);

		if(strlen(fileName) > 0) {
			loadMap(fileName);
		}
		
		delete [] fileName;
	}
	
	delete[] filenameBuffer;
}

