//#pragma warning (disable: 4786)

/*
#define UsingVisualStudioNet 0
//#define UsingVisualStudioNet 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>    
#if UsingVisualStudioNet
	#include <iostream> 
	#include <fstream>
#else
	#include <iostream.h> 
	#include <fstream.h>
#endif
#include "GLUT/glut.h"
#include "logging.h"
#include "fileDialog.h"
#include "vector"
#include "map"
#include "string"
*/

bool insideOf(Point & p) const;
double maxX, maxY, maxZ;
double minX, minY, minZ;

bool Pool::insideOf(Point & p) const {
	return p.x >= minX && p.x <= maxX &&
		   p.y >= minY && p.y <= maxY &&
		   p.z >= minZ && p.z <= maxZ;
}


	GamePoint * p;
	
	for(int i=0;i<faces.size();i++) {
		for(int j=0;j<faces.at(i)->points.size();j++) {
			p = faces.at(i)->points.at(j);
			if(i==0 && j==0) {
				maxX = p->x; minX = p->x;
				maxY = p->y; minY = p->y;
				maxZ = p->z; minZ = p->z;
			}
			else {
				if(p->x > maxX) { maxX = p->x; }
				if(p->y > maxY) { maxY = p->y; }
				if(p->z > maxZ) { maxZ = p->z; }
				if(p->x < minX) { minX = p->x; }
				if(p->y < minY) { minY = p->y; }
				if(p->z < minZ) { minZ = p->z; }
			}
		}
	}
	printf("max: (%f, %f, %f)\n", maxX, maxY, maxZ);
	printf("min: (%f, %f, %f)\n", minX, minY, minZ);


			// left side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, 0.5, 1-width, width);
			drawPoint(-0.5,0.5, -0.5, width, width);
			drawPoint(-0.5,-0.5, -0.5, width, 1-width);
			drawPoint(-0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();
			
			// right side
			glBegin(GL_POLYGON);
			drawPoint(0.5,0.5, -0.5, 1-width, width);
			drawPoint(0.5,0.5, 0.5, width, width);
			drawPoint(0.5,-0.5, 0.5, width, 1-width);
			drawPoint(0.5,-0.5, -0.5, 1-width, 1-width);
			glEnd();

			// front side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, -0.5, 1-width, width);
			drawPoint(0.5,0.5, -0.5, width, width);
			drawPoint(0.5,-0.5, -0.5, width, 1-width);
			drawPoint(-0.5,-0.5, -0.5, 1-width, 1-width);
			glEnd();

			// back side
			glBegin(GL_POLYGON);
			drawPoint(0.5,0.5, 0.5, 1-width, width);
			drawPoint(-0.5,0.5, 0.5, width, width);
			drawPoint(-0.5,-0.5, 0.5, width, 1-width);
			drawPoint(0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();

			// top side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, 0.5, 1-width, width);
			drawPoint(0.5,0.5, 0.5, width, width);
			drawPoint(0.5,0.5, -0.5, width, 1-width);
			drawPoint(-0.5,0.5, -0.5, 1-width, 1-width);
			glEnd();

			// bottom side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,-0.5, -0.5, 1-width, width);
			drawPoint(0.5,-0.5, -0.5, width, width);
			drawPoint(0.5,-0.5, 0.5, width, 1-width);
			drawPoint(-0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();


	// collect waypoints and add neighbouring waypoints to each waypoint object, then collect the waypoints in the main object collection
	char * separator;
	char * head;
	char * start;
	char * end;
	bool valid;
	bool endOfString;
	for(i=0;i<waypoints.size();i++) {
		// parse through the string of neighbour waypoint values
		head = waypoints.at(i)->neighbourValues;
		do {
			// trim whitespace
			valid = true;
			endOfString = false;
			separator = strchr(head, ',');
			if(separator == NULL) {
				separator = head + ((strlen(head) - 1) * sizeof(char) + sizeof(char));
				endOfString = true;
			}
			else {
				*separator = '\0';
			}
			start = head;
			end = separator - sizeof(char);
			// trim the front of the string
			while(*start == ' ' || *start == '\t') {
				*start = '\0';
				start += sizeof(char);
			}
			// trim the end of the string
			while(*end == ' ' || *end == '\t') {
				*end = '\0';
				end -= sizeof(char);
			}
			if(start > end) {
				valid = false;
			}
			head = start;
			
			// set each waypoint as a neighbour of the other
			if(valid) {
				for(j=0;j<waypoints.size();j++) {
					if(stricmp(head, waypoints.at(j)->name) == 0 ){
						waypoints.at(i)->addNeighbour(waypoints.at(j));
						waypoints.at(j)->addNeighbour(waypoints.at(i));
					}
				}

			}
			
			// iterate to the next element in the string
			head = separator + sizeof(char);
		} while(!endOfString);
	}



void Waypoint::addNeighbour(Waypoint * w) {
	if(w == NULL) { return; }
	
	bool valid = true;

	for(int i=0;i<this->neighbours.size();i++) {
		if(stricmp(this->neighbours.at(i)->name, w->name) == 0 || stricmp(this->name, w->name) == 0) {
			valid = false;
		}
	}
	
	if(valid) {
		this->neighbours.push_back(w);
	}
}



		else if(stricmp(key, "waypoint") == 0) {
			for(int i=0;i<waypoints.size();i++) {
				if(stricmp(waypoints.at(i)->name, str) == 0) {
					origin = waypoints.at(i);
					break;
				}
			}
			delete [] str;
		}



//Input the texture names and load the corresponding texture
	SKIP_TO_COLON;
	SKIP_TO_SEMICOLON;
	long texturesSize = atoi(line);
	CLEAR_THE_LINE;
	char * textureName;
	int startIndex;
	int i, j;
	string texturePath;
//	string texturePathBMP;
//	string texturePathTGA;
	Texture * newTexture;
	for(long textureIndex = 0; textureIndex < texturesSize; textureIndex++) {
		SKIP_TO_ENDLINE;
		startIndex = 0;
		for(i=startIndex;i<strlen(line);i++) {
			if(line[i] != ' ' && line[i] != '\t') {
				startIndex = i;
				break;
			}
		}
		textureName = new char[strlen(line) - startIndex + 1];
		j = 0;
		for(i=startIndex;i<strlen(line);i++) {
			textureName[j++] = line[i];
		}
		textureName[strlen(line) - startIndex] = '\0';

		//Load the texture
		texturePath.append(textureDirectory);
		texturePath.append("/");
		texturePath.append(textureName);
		newTexture = Texture::readTexture((char *) texturePath.c_str());
//		texturePathTGA.append(texturePath);
//		texturePathTGA.append(".tga");
//		newTexture = Texture::readTexture((char *) texturePathTGA.c_str());
//		if(newTexture == NULL) {
//			texturePathBMP.append(texturePath);
//			texturePathBMP.append(".bmp");
//			newTexture = Texture::readTexture((char *) texturePathBMP.c_str());
//		}
		if(newTexture != NULL) {
			newTexture->load();
			textures.push_back(newTexture);
		}
		else {
			prompt("Missing texture: %s", textureName);
		}
		texturePath.erase();
//		texturePathBMP.erase();
//		texturePathTGA.erase();
		delete [] textureName;
	}




//#define matches(a,b) strlen(b) >= strlen(a) && memcmp(a,b,strlen(a)) == 0

inline bool keyIsDown(int key) {
	return (GetAsyncKeyState(key) & 0x8000) != 0;
}





void Game::drawMessage(long x, long y, const char *message, ...) {
	char * text;
	text = new char[512];
	
	va_list parameters;									
	if(message == NULL) return;

	//Extract variable length parameters and copy into text as in printf.
	va_start (parameters, message);					
	    vsprintf (text, message, parameters);		
	va_end (parameters);

	//Determine the end of the string and convert each occurrence of '\n' to '\0'.
	char *end = text + strlen (text);
	for (char *next = text; *next != '\0'; next++) {
		if (*next == '\n') *next = '\0';
	}

	//Draw the multi-line message...
	begin2DDrawing ();
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_LIGHTING);
	glColor4f(1.0f,1.0f,1.0f,1.0f);
	int yOffset = y;
	for(char * line=text;line<end;line+=strlen(line)+1) {
		glRasterPos2i(x, yOffset);
		yOffset -= 32;
		privateDrawString (line);
	}
	end2DDrawing();

	delete [] text;
}

void Game::drawFrameRate () {
	//Draw the frame rate avoiding extreme fluctuations (since all you see is flickering).
	double frameRate = 1.0 / DT; //Frames/sec = 1/(seconds per frame).
	static double stableRate = frameRate; //This initializes only the first time...
	static double oldFrameRate = frameRate;
	//If it changed by more than 2 per cent of the stable value, use the new value; otherwise use the stable one...
	if(absolute(frameRate - stableRate) > 2.0) stableRate  = frameRate; 
	drawMessage(1, screenHeight-20, "FPS: %3.1f", stableRate);
}

void Game::drawNote (const char *message, ...) {
	char text[1000];
	va_list parameters;									
	if (message == NULL) return;
	
	//Extract variable length parameters and copy into text as in printf.
	va_start(parameters, message);					
	    vsprintf(text, message, parameters);		
	va_end(parameters);

	drawMessage(1, screenHeight-52, "%s", text);
}




void Game::loadMapPrompt() {
	closeWorld();
	
	char * fileName = NULL;
	char * filenameBuffer = new char[MAX_PATH];
	filenameBuffer[0] = '\0';
	
	OPENFILENAME query;
	query.lStructSize = sizeof(OPENFILENAME);
	query.hwndOwner = NULL;
	query.hInstance = GetModuleHandle(NULL);
	query.lpstrFilter = worldFileFilter;
	query.lpstrCustomFilter = NULL;
	query.nMaxCustFilter = 0;
	query.nFilterIndex = 0;
	query.lpstrFile = filenameBuffer;
	query.nMaxFile = MAX_PATH;
	query.lpstrFileTitle = NULL;
	query.nMaxFileTitle = MAX_PATH;
	query.lpstrInitialDir = settings->getValue("Map Directory");
	query.lpstrTitle = NULL;
	query.Flags = OFN_NOCHANGEDIR;
	query.nFileOffset = 0;
	query.nFileExtension = 0;
	query.lpstrDefExt = NULL;
	query.lCustData = 0;
	query.lpfnHook = NULL;
	query.lpTemplateName = NULL;
	
	if(GetOpenFileName(&query)) {
		fileName = new char[strlen(query.lpstrFile) + 1];
		strcpy(fileName, query.lpstrFile);

		if(strlen(fileName) > 0) {
			loadMap(fileName);
		}
		
		delete [] fileName;
	}
	
	delete[] filenameBuffer;
}


/*

//Macro "declareCollection" below declares a type of vector, e.g., declareCollection (Face);
//creates a vector of Face pointers.

//There are two ways to use such a collection

//	1. Typical way of using a collection:
//
//			FaceCollection faces; 
//			Face *face1 = ...; faces.push_back (face1); 
//			Face *face2 = ...; faces.push_back (face2);
//				...
//			loopVector (index, faces)
//				... faces [index] .... //provides an element of type Face *.
//			endloop
//			deleteFaceCollectionEntries (faces); //faces is deleted when the object containing it is deleted...

//	2. More unusual way (using a pointer to a collection):
//
//			FaceCollection *faces = new FaceCollection; 
//			Face *face1 = ...; faces->push_back (face1); 
//			Face *face2 = ...; faces->push_back (face2);
//				...
//			loopVector (index, *faces)
//				... (*faces) [index] .... //provides an element of type Face *.
//			endloop
//			deleteFaceCollection (faces); //deletes the entries and also faces itself...

#define declareCollection(type) \
	typedef vector <type *> type##Collection; \
	typedef vector <type *>::iterator type##CollectionIterator; \
		\
	inline void delete##type##CollectionEntries (type##Collection &collection) { \
		for (long index = 0; index < collection.size (); index++) { \
			delete collection [index]; \
		} \
	} \
	inline void delete##type##Collection (type##Collection *collection) { \
		delete##type##CollectionEntries (*collection); \
		delete collection; \
	}

#define loopVector(variable,vector) {for (long variable = 0; variable < (vector).size (); variable++) {
#define endloop }}


//Create a special kind for dealing with strings...
declareCollection (char); 
typedef charCollection StringCollection;
inline void deleteStringCollectionEntries (StringCollection &collection) {
	loopVector (index, collection)
		delete [] collection [index]; //What is different from the version above...
	endloop
}

inline void deleteStringCollection (StringCollection *collection) { 
	deleteStringCollectionEntries (*collection); 
	delete collection; 
} 

//Example use:
//	StringCollection test;
//	test.push_back("hello");
//	test.push_back("there");
//	test.push_back("you");
//	loopVector (index, test)
//		if (stricmp (test [index], "brick") == 0) ::log ("\nBrick is at index %d.", index);
//		::log ("\nString %d is \"%s\"...", index, test [index]);
//	endloop




//Macro "declareDictionary" below declares a type of map, e.g., declareDictionary (Face)
//creates a map that associates strings with Face pointers.

//There are two ways to use such a collection

//	1. Typical way of using a dictionary:
//
//			FaceDictionary faces; 
//			Face *face1 = ...; put (faces, "name1", face1); //Storing
//			Face *face2 = ...; put (faces, "name2", face2); 
//				...
//			Face *face = get (faces, "name1"); //Retrieving: get NULL if not found...
//			put (faces, "name1", face2); //Changing...
//			loopDictionary (faceKey, faceValue, faces, Face)
//				... faceValue .... //faceValue is locally declared by the loop macro to be type Face * and initialized...
//			endloop
//			deleteFaceDictionaryEntries (faces); //faces is deleted when the object containing it is deleted...

//	2. More unusual way (using a pointer to a collection):
//
//			FaceDictionary *faces = new FaceDictionary; 
//			As above but use "faces->" instead of "faces." or *faces instead of faces.
//			deleteFaceDictionary (faces); //deletes the entries and also faces itself...

#define loopDictionary(key,value,map,type) \
	{for (type##DictionaryIterator iterator = (map).begin (); iterator != (map).end (); ++iterator) { \
		const char *key = iterator->first.c_str (); \
		type *value = iterator->second;

#define declareDictionary(type) \
	typedef map <string, type *> type##Dictionary; \
	typedef type##Dictionary::iterator type##DictionaryIterator; \
		\
	inline void delete##type##DictionaryEntries (type##Dictionary &collection) { \
		loopDictionary (key, value, collection, type) \
			delete value; \
		endloop \
	} \
	inline void delete##type##Dictionary (type##Dictionary *collection) { \
		delete##type##DictionaryEntries (*collection); \
		delete collection; \
	} \
		\
	inline type *get (type##Dictionary &collection, char *key) { \
		type##DictionaryIterator result = collection.find (key); \
		if (result == collection.end ()) return NULL; \
		return result->second; \
	} \
	inline void put (type##Dictionary &collection, char *key, type *value) { \
		collection.insert (type##Dictionary::value_type (key, value)); \
	}

//Create a special kind for dealing with properties...
declareDictionary (char); 
typedef charDictionary StringDictionary;
inline void deleteStringDictionaryEntries (StringDictionary &collection) {
	loopDictionary (key, value, collection, char)
		delete [] value; //What is different from the version above...
	endloop
}

inline void deleteStringDictionary (StringDictionary *collection) { 
	deleteStringDictionaryEntries (*collection); 
	delete collection; 
} 

//If you need a forward reference to a collection, you will need the following macros.
//An example would be if class Object itself needs to keep track of a collection of sub-objects.
//In that case, you would need to declare a collection of objects but you will have difficulty
//doing this before the class definition...

#define preDeclareCollection(classOrStruct,type) \
	classOrStruct type; \
	typedef vector <type *> type##Collection;

#define preDeclareDictionary(classOrStruct,type) \
	classOrStruct type; \
	typedef vector <type *> type##Collection;

*/


#include "Utilities.h"

void convertToLowercaseX (char *name) {
	for (long index = strlen (name) - 1; index >= 0; index--) {
		name [index] = tolower (name [index]);
	}
}

//Useful utility...
void convertToLowercaseX (char *name);


/*void genericMenuHandler(int item) {
	switch(item) {
		case RunWorld:
			game->loadMap();
			break;
	}
}

void createMenus () {
	int genericMenu = glutCreateMenu (genericMenuHandler);
	glutAddMenuEntry ("Run World", RunWorld);
	glutAttachMenu (GLUT_RIGHT_BUTTON);
}*/

//		createMenus();


#ifndef _UTILITIES_H
#define _UTILITIES_H

#include "Includes.h"

//Generic macros for reading world files...
//Note: input.getline (line, 256, c) => picks up everything up to c exclusive and discards c.

//#define SKIP_TO(character) input.getline (line, 256, character)
//#define SKIP_TO_ENDLINE SKIP_TO ('\n')
//#define SKIP_TO_COMMA SKIP_TO (',')
//#define SKIP_TO_COLON SKIP_TO (':')
//#define SKIP_TO_SEMICOLON SKIP_TO (';')
//#define CLEAR_THE_LINE SKIP_TO_ENDLINE

#endif





/*
	//Input the transformation.
	input.getline(line, 256, ':'); input.getline(line, 256, '\n');
	
	//The standard transformation matrix elements...
	Transformation &normal = transformation.normal ();
	input.getline(line, 256, ','); normal.m11 = atof (line);
	input.getline(line, 256, ','); normal.m12 = atof (line);
	input.getline(line, 256, ','); normal.m13 = atof (line);
	input.getline(line, 256, ','); normal.m14 = atof (line);
	
	input.getline(line, 256, ','); normal.m21 = atof (line);
	input.getline(line, 256, ','); normal.m22 = atof (line);
	input.getline(line, 256, ','); normal.m23 = atof (line);
	input.getline(line, 256, ','); normal.m24 = atof (line);
	
	input.getline(line, 256, ','); normal.m31 = atof (line);
	input.getline(line, 256, ','); normal.m32 = atof (line);
	input.getline(line, 256, ','); normal.m33 = atof (line);
	input.getline(line, 256, ','); normal.m34 = atof (line);
	
	input.getline(line, 256, ','); normal.m41 = atof (line);
	input.getline(line, 256, ','); normal.m42 = atof (line);
	input.getline(line, 256, ','); normal.m43 = atof (line);
	input.getline(line, 256, ';'); normal.m44 = atof (line);
	input.getline(line, 256, '\n');

	//The inverse transformation matrix elements...
	Transformation &inverse = transformation.inverse;
	input.getline(line, 256, ','); inverse.m11 = atof (line);
	input.getline(line, 256, ','); inverse.m12 = atof (line);
	input.getline(line, 256, ','); inverse.m13 = atof (line);
	input.getline(line, 256, ','); inverse.m14 = atof (line);
	
	input.getline(line, 256, ','); inverse.m21 = atof (line);
	input.getline(line, 256, ','); inverse.m22 = atof (line);
	input.getline(line, 256, ','); inverse.m23 = atof (line);
	input.getline(line, 256, ','); inverse.m24 = atof (line);
	
	input.getline(line, 256, ','); inverse.m31 = atof (line);
	input.getline(line, 256, ','); inverse.m32 = atof (line);
	input.getline(line, 256, ','); inverse.m33 = atof (line);
	input.getline(line, 256, ','); inverse.m34 = atof (line);
	
	input.getline(line, 256, ','); inverse.m41 = atof (line);
	input.getline(line, 256, ','); inverse.m42 = atof (line);
	input.getline(line, 256, ','); inverse.m43 = atof (line);
	input.getline(line, 256, ';'); inverse.m44 = atof (line);
	input.getline(line, 256, '\n');
	*/





double timeNow();

double timeNow() {
	//Returns how much time has elapsed since the first call of this function... Accurate to a microsecond...
	static INT64 countsPerSecond; static INT64 oldTime; static bool firstTime = true;
	if (firstTime) {firstTime = false; QueryPerformanceCounter ((LARGE_INTEGER *) &oldTime); QueryPerformanceFrequency ((LARGE_INTEGER *) &countsPerSecond);}
	
	INT64 newTime; QueryPerformanceCounter ((LARGE_INTEGER *) &newTime);
	INT64 elapsedCounts = newTime - oldTime; 
	
	double seconds = (double) elapsedCounts / (double) countsPerSecond; //count / (counts / second) = seconds
	return seconds;
}



inline char *fileSuffix (const char *fileName) {
	//Returns a pointer to an ALL UPPERCASE string in a static area containing the 3 CHARACTER SUFFIX SUCH AS
	//"BMP" OR "TGA". Don't call twice on 2 different file names and then process (call once, process, call 
	//again, process, ...).
	long size = strlen (fileName); static char uppercase [5];
	for (char *s = (char *) &fileName [size - 4], *d = &uppercase [0]; *s; s++, d++) {
		*d = toupper (*s);
	}
	uppercase [4] = '\0'; //Make sure the file extension ends with a NULL
	return uppercase;
}

//	static Texture * readUnknownTexture(char *shortTextureName, const bool haltIfNotFound = true);

/*Texture *Texture::readUnknownTexture(char *shortTextureName, const bool haltIfNotFound) {
	//Given a short texture name such as "brick", builds a full path name such as
	//"c:\3d\student\textures\brick.tga" and then tries to read it to see if it exists.
	//If it exists, it is returned. Otherwise, tries ".bmp" as the suffix... If that
	//fails, either returns NULL or gives an error message depending on "haltIfNotFound". 
	
	//Basic idea: tga files are preferred over bmp files...
	const long maximumSuffixes = 2;
	static char * suffixes[] = {".tga", ".bmp"};
	static char fileName[500]; 
	
	for(long suffixIndex = 0; suffixIndex < maximumSuffixes; suffixIndex++) {
		strcpy(fileName, "..\\textures\\");
		strcat(fileName, shortTextureName);
		strcat(fileName, suffixes [suffixIndex]);
		
		Texture *texture = Texture::readTexture (fileName);
		if (texture != NULL) return texture;
	}
	
	//If we get to here, it's because none of the suffixes worked.
	if(haltIfNotFound) {
		printf("Could not find texture \"%s\" in the textures directory...\n", shortTextureName);
	}
	return NULL;
}*/


//	static bool readTextureExtent(char * fileName, long & width, long & height);
//	static bool readRGBTextureExtent(char * fullPathName, long & width, long & height);
//	static bool readTGATextureExtent(char * fullPathName, long & width, long & height);

/*bool Texture::readTextureExtent(char * fullPathName, long & width, long & height) {
	//Read just enough of a texture to determine it's extent; i.e., width and height.
	//Returns true if successful; false otherwise. Special case 3 possibilities...
	char * suffix = strrchr(fullPathName, '.');
	if(stricmp(suffix, ".bmp") == 0) {
		return readRGBTextureExtent(fullPathName, width, height);
	}
	if(stricmp(suffix, ".tga") == 0) {
		return readTGATextureExtent(fullPathName, width, height);
	}
	quit("Unknown texture type for \"%s\".\n", fullPathName);
	return false;
}

bool Texture::readRGBTextureExtent(char * fullPathName, long & width, long & height) {
	//Read just enough of a texture to determine it's extent; i.e., width and height.
	//Returns true if successful; false otherwise.

	//Get Microsoft to read it (they must know how).
    HBITMAP bitmapHandle = (HBITMAP) LoadImage (NULL, fullPathName, 
    	IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);	
	if (bitmapHandle == NULL) {
		printf("File \"%s\" not found...\n", fullPathName);
		return false;
	}

    //Find out how big it is.
	BITMAP bitmap; GetObject (bitmapHandle, sizeof (bitmap), &bitmap);
	width = bitmap.bmWidth;	height = bitmap.bmHeight;
	DeleteObject (bitmapHandle); 
	return true;
}

bool Texture::readTGATextureExtent(char * fullPathName, long & width, long & height) {
	//Read just enough of a texture to determine it's extent; i.e., width and height.
	//Returns true if successful; false otherwise.

	FILE *file = fopen (fullPathName, "rb");
	if (file == NULL) {
		printf("Unable to open texture %s\n", fullPathName);
		return false;
	}

	struct TGAHeader {
		byte idLength, colorMapType, imageType, colorMapSpecification [5];
		short xOrigin, yOrigin, imageWidth, imageHeight;
		byte pixelDepth, imageDescriptor;
	};

	TGAHeader header;
	if (fread (&header, 1, sizeof (header), file) != sizeof (header)) {
		printf("TGA file \"%s\" appears to be truncated.\n", fullPathName);
		return false;
	}
	fclose (file);
	width = header.imageWidth;
	height = header.imageHeight; 
	return true;
}*/

inline bool isPowerOf2(long value) {
	return (value & ~(value - 1)) == value;
}


/*
#define redMask 0X000000FF
#define greenMask 0X0000FF00
#define blueMask 0X00FF0000
#define alphaMask 0XFF000000
*/

#define redShift 0
#define greenShift 8
#define blueShift 16
#define alphaShift 24


/*inline long unpackRed(const long pixel) {
	return (pixel >> redShift) & 0X000000FF;
}

inline long unpackGreen(const long pixel) {
	return (pixel >> greenShift) & 0X000000FF;
}

inline long unpackBlue(const long pixel) {
	return (pixel >> blueShift) & 0X000000FF;
}

inline long unpackAlpha(const long pixel) {
	return (pixel >> alphaShift) & 0X000000FF;
}*/

//#define setupStaticBuffer() \
//	static char buffer [500]; va_list parameters; \
//	va_start(parameters, message); \
//	vsprintf(buffer, message, parameters); \
//	va_end(parameters) 



		
		/*
		ByteArrayOutputStream baos = new ByteArrayOutputStream(size);
		ImageIO.write(heightMap, "bmp", baos);
		baos.flush();
		byte[] heightMapBytes = baos.toByteArray();
		baos.close();
		*/


//enum MenuItem {DifficultyEasy, DifficultyChallenging, DifficultyImpossible,
//	DisplayModeWireframe, DisplayModeTextured, RunWorld, Quit};
//MenuItem difficulty;
//MenuItem displayMode;


	glColor4f(0, 0, 1, 1);
	glDisable(GL_BLEND);
	glBegin(GL_LINE_STRIP);
		glVertex3d(origin->getPosition().x, origin->getPosition().y + (extent.y/2), origin->getPosition().z);
		glVertex3d(position.x, position.y + (extent.y/2), position.z);
	glEnd();
	glEnable(GL_BLEND);
	glColor4f(1, 1, 1, 1);


		glColor4f(0, 1, 0, 1);
		glDisable(GL_BLEND);
		glutWireSphere(0.5, 10, 10);
		glEnable(GL_BLEND);
		glColor4f(1, 1, 1, 1);

