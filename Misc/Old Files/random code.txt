//#pragma warning (disable: 4786)

/*
#define UsingVisualStudioNet 0
//#define UsingVisualStudioNet 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>    
#if UsingVisualStudioNet
	#include <iostream> 
	#include <fstream>
#else
	#include <iostream.h> 
	#include <fstream.h>
#endif
#include "GLUT/glut.h"
#include "logging.h"
#include "fileDialog.h"
#include "vector"
#include "map"
#include "string"
*/

bool insideOf(Point & p) const;
double maxX, maxY, maxZ;
double minX, minY, minZ;

bool Pool::insideOf(Point & p) const {
	return p.x >= minX && p.x <= maxX &&
		   p.y >= minY && p.y <= maxY &&
		   p.z >= minZ && p.z <= maxZ;
}


	GamePoint * p;
	
	for(int i=0;i<faces.size();i++) {
		for(int j=0;j<faces.at(i)->points.size();j++) {
			p = faces.at(i)->points.at(j);
			if(i==0 && j==0) {
				maxX = p->x; minX = p->x;
				maxY = p->y; minY = p->y;
				maxZ = p->z; minZ = p->z;
			}
			else {
				if(p->x > maxX) { maxX = p->x; }
				if(p->y > maxY) { maxY = p->y; }
				if(p->z > maxZ) { maxZ = p->z; }
				if(p->x < minX) { minX = p->x; }
				if(p->y < minY) { minY = p->y; }
				if(p->z < minZ) { minZ = p->z; }
			}
		}
	}
	printf("max: (%f, %f, %f)\n", maxX, maxY, maxZ);
	printf("min: (%f, %f, %f)\n", minX, minY, minZ);


			// left side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, 0.5, 1-width, width);
			drawPoint(-0.5,0.5, -0.5, width, width);
			drawPoint(-0.5,-0.5, -0.5, width, 1-width);
			drawPoint(-0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();
			
			// right side
			glBegin(GL_POLYGON);
			drawPoint(0.5,0.5, -0.5, 1-width, width);
			drawPoint(0.5,0.5, 0.5, width, width);
			drawPoint(0.5,-0.5, 0.5, width, 1-width);
			drawPoint(0.5,-0.5, -0.5, 1-width, 1-width);
			glEnd();

			// front side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, -0.5, 1-width, width);
			drawPoint(0.5,0.5, -0.5, width, width);
			drawPoint(0.5,-0.5, -0.5, width, 1-width);
			drawPoint(-0.5,-0.5, -0.5, 1-width, 1-width);
			glEnd();

			// back side
			glBegin(GL_POLYGON);
			drawPoint(0.5,0.5, 0.5, 1-width, width);
			drawPoint(-0.5,0.5, 0.5, width, width);
			drawPoint(-0.5,-0.5, 0.5, width, 1-width);
			drawPoint(0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();

			// top side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,0.5, 0.5, 1-width, width);
			drawPoint(0.5,0.5, 0.5, width, width);
			drawPoint(0.5,0.5, -0.5, width, 1-width);
			drawPoint(-0.5,0.5, -0.5, 1-width, 1-width);
			glEnd();

			// bottom side
			glBegin(GL_POLYGON);
			drawPoint(-0.5,-0.5, -0.5, 1-width, width);
			drawPoint(0.5,-0.5, -0.5, width, width);
			drawPoint(0.5,-0.5, 0.5, width, 1-width);
			drawPoint(-0.5,-0.5, 0.5, 1-width, 1-width);
			glEnd();


	// collect waypoints and add neighbouring waypoints to each waypoint object, then collect the waypoints in the main object collection
	char * separator;
	char * head;
	char * start;
	char * end;
	bool valid;
	bool endOfString;
	for(i=0;i<waypoints.size();i++) {
		// parse through the string of neighbour waypoint values
		head = waypoints.at(i)->neighbourValues;
		do {
			// trim whitespace
			valid = true;
			endOfString = false;
			separator = strchr(head, ',');
			if(separator == NULL) {
				separator = head + ((strlen(head) - 1) * sizeof(char) + sizeof(char));
				endOfString = true;
			}
			else {
				*separator = '\0';
			}
			start = head;
			end = separator - sizeof(char);
			// trim the front of the string
			while(*start == ' ' || *start == '\t') {
				*start = '\0';
				start += sizeof(char);
			}
			// trim the end of the string
			while(*end == ' ' || *end == '\t') {
				*end = '\0';
				end -= sizeof(char);
			}
			if(start > end) {
				valid = false;
			}
			head = start;
			
			// set each waypoint as a neighbour of the other
			if(valid) {
				for(j=0;j<waypoints.size();j++) {
					if(stricmp(head, waypoints.at(j)->name) == 0 ){
						waypoints.at(i)->addNeighbour(waypoints.at(j));
						waypoints.at(j)->addNeighbour(waypoints.at(i));
					}
				}

			}
			
			// iterate to the next element in the string
			head = separator + sizeof(char);
		} while(!endOfString);
	}



void Waypoint::addNeighbour(Waypoint * w) {
	if(w == NULL) { return; }
	
	bool valid = true;

	for(int i=0;i<this->neighbours.size();i++) {
		if(stricmp(this->neighbours.at(i)->name, w->name) == 0 || stricmp(this->name, w->name) == 0) {
			valid = false;
		}
	}
	
	if(valid) {
		this->neighbours.push_back(w);
	}
}



		else if(stricmp(key, "waypoint") == 0) {
			for(int i=0;i<waypoints.size();i++) {
				if(stricmp(waypoints.at(i)->name, str) == 0) {
					origin = waypoints.at(i);
					break;
				}
			}
			delete [] str;
		}



//Input the texture names and load the corresponding texture
	SKIP_TO_COLON;
	SKIP_TO_SEMICOLON;
	long texturesSize = atoi(line);
	CLEAR_THE_LINE;
	char * textureName;
	int startIndex;
	int i, j;
	string texturePath;
//	string texturePathBMP;
//	string texturePathTGA;
	Texture * newTexture;
	for(long textureIndex = 0; textureIndex < texturesSize; textureIndex++) {
		SKIP_TO_ENDLINE;
		startIndex = 0;
		for(i=startIndex;i<strlen(line);i++) {
			if(line[i] != ' ' && line[i] != '\t') {
				startIndex = i;
				break;
			}
		}
		textureName = new char[strlen(line) - startIndex + 1];
		j = 0;
		for(i=startIndex;i<strlen(line);i++) {
			textureName[j++] = line[i];
		}
		textureName[strlen(line) - startIndex] = '\0';

		//Load the texture
		texturePath.append(textureDirectory);
		texturePath.append("/");
		texturePath.append(textureName);
		newTexture = Texture::readTexture((char *) texturePath.c_str());
//		texturePathTGA.append(texturePath);
//		texturePathTGA.append(".tga");
//		newTexture = Texture::readTexture((char *) texturePathTGA.c_str());
//		if(newTexture == NULL) {
//			texturePathBMP.append(texturePath);
//			texturePathBMP.append(".bmp");
//			newTexture = Texture::readTexture((char *) texturePathBMP.c_str());
//		}
		if(newTexture != NULL) {
			newTexture->load();
			textures.push_back(newTexture);
		}
		else {
			prompt("Missing texture: %s", textureName);
		}
		texturePath.erase();
//		texturePathBMP.erase();
//		texturePathTGA.erase();
		delete [] textureName;
	}


